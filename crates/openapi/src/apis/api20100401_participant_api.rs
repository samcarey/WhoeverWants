/*
 * Twilio - Api
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.55.0
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_participant`]
#[derive(Clone, Debug)]
pub struct CreateParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that will create the resource.
    pub account_sid: String,
    /// The SID of the participant's conference.
    pub conference_sid: String,
    /// The phone number, Client identifier, or username portion of SIP address that made this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). Client identifiers are formatted `client:name`. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the `to` parameter is a phone number, `from` must also be a phone number. If `to` is sip address, this value of `from` should be a username portion to be used to populate the P-Asserted-Identity header that is passed to the SIP endpoint.
    pub from: String,
    /// The phone number, SIP address, or Client identifier that received this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). SIP addresses are formatted as `sip:name@company.com`. Client identifiers are formatted `client:name`. [Custom parameters](https://www.twilio.com/docs/voice/api/conference-participant-resource#custom-parameters) may also be specified.
    pub to: String,
    /// The URL we should call using the `status_callback_method` to send status information to your application.
    pub status_callback: Option<String>,
    /// The HTTP method we should use to call `status_callback`. Can be: `GET` and `POST` and defaults to `POST`.
    pub status_callback_method: Option<String>,
    /// The conference state changes that should generate a call to `status_callback`. Can be: `initiated`, `ringing`, `answered`, and `completed`. Separate multiple values with a space. The default value is `completed`.
    pub status_callback_event: Option<Vec<String>>,
    /// A label for this participant. If one is supplied, it may subsequently be used to fetch, update or delete the participant.
    pub label: Option<String>,
    /// The number of seconds that we should allow the phone to ring before assuming there is no answer. Can be an integer between `5` and `600`, inclusive. The default value is `60`. We always add a 5-second timeout buffer to outgoing calls, so  value of 10 would result in an actual timeout that was closer to 15 seconds.
    pub timeout: Option<i32>,
    /// Whether to record the participant and their conferences, including the time between conferences. Can be `true` or `false` and the default is `false`.
    pub record: Option<bool>,
    /// Whether the agent is muted in the conference. Can be `true` or `false` and the default is `false`.
    pub muted: Option<bool>,
    /// Whether to play a notification beep to the conference when the participant joins. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
    pub beep: Option<String>,
    /// Whether to start the conference when the participant joins, if it has not already started. Can be: `true` or `false` and the default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
    pub start_conference_on_enter: Option<bool>,
    /// Whether to end the conference when the participant leaves. Can be: `true` or `false` and defaults to `false`.
    pub end_conference_on_exit: Option<bool>,
    /// The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
    pub wait_url: Option<String>,
    /// The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
    pub wait_method: Option<String>,
    /// Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. Can be: `true` or `false` and defaults to `true`.
    pub early_media: Option<bool>,
    /// The maximum number of participants in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
    pub max_participants: Option<i32>,
    /// Whether to record the conference the participant is joining. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
    pub conference_record: Option<String>,
    /// Whether to trim leading and trailing silence from the conference recording. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
    pub conference_trim: Option<String>,
    /// The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
    pub conference_status_callback: Option<String>,
    /// The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub conference_status_callback_method: Option<String>,
    /// The conference state changes that should generate a call to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `modify`, `speaker`, and `announcement`. Separate multiple values with a space. Defaults to `start end`.
    pub conference_status_callback_event: Option<Vec<String>>,
    /// The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
    pub recording_channels: Option<String>,
    /// The URL that we should call using the `recording_status_callback_method` when the recording status changes.
    pub recording_status_callback: Option<String>,
    /// The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub recording_status_callback_method: Option<String>,
    /// The SIP username used for authentication.
    pub sip_auth_username: Option<String>,
    /// The SIP password for authentication.
    pub sip_auth_password: Option<String>,
    /// The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
    pub region: Option<String>,
    /// The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
    pub conference_recording_status_callback: Option<String>,
    /// The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
    pub conference_recording_status_callback_method: Option<String>,
    /// The recording state changes that should generate a call to `recording_status_callback`. Can be: `started`, `in-progress`, `paused`, `resumed`, `stopped`, `completed`, `failed`, and `absent`. Separate multiple values with a space, ex: `'in-progress completed failed'`.
    pub recording_status_callback_event: Option<Vec<String>>,
    /// The conference recording state changes that generate a call to `conference_recording_status_callback`. Can be: `in-progress`, `completed`, `failed`, and `absent`. Separate multiple values with a space, ex: `'in-progress completed failed'`
    pub conference_recording_status_callback_event: Option<Vec<String>>,
    /// Whether the participant is coaching another call. Can be: `true` or `false`. If not present, defaults to `false` unless `call_sid_to_coach` is defined. If `true`, `call_sid_to_coach` must be defined.
    pub coaching: Option<bool>,
    /// The SID of the participant who is being `coached`. The participant being coached is the only participant who can hear the participant who is `coaching`.
    pub call_sid_to_coach: Option<String>,
    /// Jitter buffer size for the connecting participant. Twilio will use this setting to apply Jitter Buffer before participant's audio is mixed into the conference. Can be: `off`, `small`, `medium`, and `large`. Default to `large`.
    pub jitter_buffer_size: Option<String>,
    /// The SID of a BYOC (Bring Your Own Carrier) trunk to route this call with. Note that `byoc` is only meaningful when `to` is a phone number; it will otherwise be ignored. (Beta)
    pub byoc: Option<String>,
    /// The phone number, Client identifier, or username portion of SIP address that made this call. Phone numbers are in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (e.g., +16175551212). Client identifiers are formatted `client:name`. If using a phone number, it must be a Twilio number or a Verified [outgoing caller id](https://www.twilio.com/docs/voice/api/outgoing-caller-ids) for your account. If the `to` parameter is a phone number, `callerId` must also be a phone number. If `to` is sip address, this value of `callerId` should be a username portion to be used to populate the From header that is passed to the SIP endpoint.
    pub caller_id: Option<String>,
    /// The Reason for the outgoing call. Use it to specify the purpose of the call that is presented on the called party's phone. (Branded Calls Beta)
    pub call_reason: Option<String>,
    /// The audio track to record for the call. Can be: `inbound`, `outbound` or `both`. The default is `both`. `inbound` records the audio that is received by Twilio. `outbound` records the audio that is sent from Twilio. `both` records the audio that is received and sent by Twilio.
    pub recording_track: Option<String>,
    /// The maximum duration of the call in seconds. Constraints depend on account and configuration.
    pub time_limit: Option<i32>,
    /// Whether to detect if a human, answering machine, or fax has picked up the call. Can be: `Enable` or `DetectMessageEnd`. Use `Enable` if you would like us to return `AnsweredBy` as soon as the called party is identified. Use `DetectMessageEnd`, if you would like to leave a message on an answering machine. For more information, see [Answering Machine Detection](https://www.twilio.com/docs/voice/answering-machine-detection).
    pub machine_detection: Option<String>,
    /// The number of seconds that we should attempt to detect an answering machine before timing out and sending a voice request with `AnsweredBy` of `unknown`. The default timeout is 30 seconds.
    pub machine_detection_timeout: Option<i32>,
    /// The number of milliseconds that is used as the measuring stick for the length of the speech activity, where durations lower than this value will be interpreted as a human and longer than this value as a machine. Possible Values: 1000-6000. Default: 2400.
    pub machine_detection_speech_threshold: Option<i32>,
    /// The number of milliseconds of silence after speech activity at which point the speech activity is considered complete. Possible Values: 500-5000. Default: 1200.
    pub machine_detection_speech_end_threshold: Option<i32>,
    /// The number of milliseconds of initial silence after which an `unknown` AnsweredBy result will be returned. Possible Values: 2000-10000. Default: 5000.
    pub machine_detection_silence_timeout: Option<i32>,
    /// The URL that we should call using the `amd_status_callback_method` to notify customer application whether the call was answered by human, machine or fax.
    pub amd_status_callback: Option<String>,
    /// The HTTP method we should use when calling the `amd_status_callback` URL. Can be: `GET` or `POST` and the default is `POST`.
    pub amd_status_callback_method: Option<String>,
    /// Whether to trim any leading and trailing silence from the participant recording. Can be: `trim-silence` or `do-not-trim` and the default is `trim-silence`.
    pub trim: Option<String>,
    /// A token string needed to invoke a forwarded call. A call_token is generated when an incoming call is received on a Twilio number. Pass an incoming call's call_token value to a forwarded call via the call_token parameter when creating a new call. A forwarded call should bear the same CallerID of the original incoming call.
    pub call_token: Option<String>
}

/// struct for passing parameters to the method [`delete_participant`]
#[derive(Clone, Debug)]
pub struct DeleteParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resources to delete.
    pub account_sid: String,
    /// The SID of the conference with the participants to delete.
    pub conference_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID or label of the participant to delete. Non URL safe characters in a label must be percent encoded, for example, a space character is represented as %20.
    pub call_sid: String
}

/// struct for passing parameters to the method [`fetch_participant`]
#[derive(Clone, Debug)]
pub struct FetchParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resource to fetch.
    pub account_sid: String,
    /// The SID of the conference with the participant to fetch.
    pub conference_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID or label of the participant to fetch. Non URL safe characters in a label must be percent encoded, for example, a space character is represented as %20.
    pub call_sid: String
}

/// struct for passing parameters to the method [`list_participant`]
#[derive(Clone, Debug)]
pub struct ListParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resources to read.
    pub account_sid: String,
    /// The SID of the conference with the participants to read.
    pub conference_sid: String,
    /// Whether to return only participants that are muted. Can be: `true` or `false`.
    pub muted: Option<bool>,
    /// Whether to return only participants that are on hold. Can be: `true` or `false`.
    pub hold: Option<bool>,
    /// Whether to return only participants who are coaching another call. Can be: `true` or `false`.
    pub coaching: Option<bool>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i32>,
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`update_participant`]
#[derive(Clone, Debug)]
pub struct UpdateParticipantParams {
    /// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Participant resources to update.
    pub account_sid: String,
    /// The SID of the conference with the participant to update.
    pub conference_sid: String,
    /// The [Call](https://www.twilio.com/docs/voice/api/call-resource) SID or label of the participant to update. Non URL safe characters in a label must be percent encoded, for example, a space character is represented as %20.
    pub call_sid: String,
    /// Whether the participant should be muted. Can be `true` or `false`. `true` will mute the participant, and `false` will un-mute them. Anything value other than `true` or `false` is interpreted as `false`.
    pub muted: Option<bool>,
    /// Whether the participant should be on hold. Can be: `true` or `false`. `true` puts the participant on hold, and `false` lets them rejoin the conference.
    pub hold: Option<bool>,
    /// The URL we call using the `hold_method` for music that plays when the participant is on hold. The URL may return an MP3 file, a WAV file, or a TwiML document that contains `<Play>`, `<Say>`, `<Pause>`, or `<Redirect>` verbs.
    pub hold_url: Option<String>,
    /// The HTTP method we should use to call `hold_url`. Can be: `GET` or `POST` and the default is `GET`.
    pub hold_method: Option<String>,
    /// The URL we call using the `announce_method` for an announcement to the participant. The URL may return an MP3 file, a WAV file, or a TwiML document that contains `<Play>`, `<Say>`, `<Pause>`, or `<Redirect>` verbs.
    pub announce_url: Option<String>,
    /// The HTTP method we should use to call `announce_url`. Can be: `GET` or `POST` and defaults to `POST`.
    pub announce_method: Option<String>,
    /// The URL we call using the `wait_method` for the music to play while participants are waiting for the conference to start. The URL may return an MP3 file, a WAV file, or a TwiML document that contains `<Play>`, `<Say>`, `<Pause>`, or `<Redirect>` verbs. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
    pub wait_url: Option<String>,
    /// The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
    pub wait_method: Option<String>,
    /// Whether to play a notification beep to the conference when the participant exits. Can be: `true` or `false`.
    pub beep_on_exit: Option<bool>,
    /// Whether to end the conference when the participant leaves. Can be: `true` or `false` and defaults to `false`.
    pub end_conference_on_exit: Option<bool>,
    /// Whether the participant is coaching another call. Can be: `true` or `false`. If not present, defaults to `false` unless `call_sid_to_coach` is defined. If `true`, `call_sid_to_coach` must be defined.
    pub coaching: Option<bool>,
    /// The SID of the participant who is being `coached`. The participant being coached is the only participant who can hear the participant who is `coaching`.
    pub call_sid_to_coach: Option<String>
}


/// struct for typed errors of method [`create_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListParticipantError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_participant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateParticipantError {
    UnknownValue(serde_json::Value),
}


/// 
pub async fn create_participant(configuration: &configuration::Configuration, params: CreateParticipantParams) -> Result<crate::models::ApiPeriodV2010PeriodAccountPeriodConferencePeriodParticipant, Error<CreateParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let from = params.from;
    let to = params.to;
    let status_callback = params.status_callback;
    let status_callback_method = params.status_callback_method;
    let status_callback_event = params.status_callback_event;
    let label = params.label;
    let timeout = params.timeout;
    let record = params.record;
    let muted = params.muted;
    let beep = params.beep;
    let start_conference_on_enter = params.start_conference_on_enter;
    let end_conference_on_exit = params.end_conference_on_exit;
    let wait_url = params.wait_url;
    let wait_method = params.wait_method;
    let early_media = params.early_media;
    let max_participants = params.max_participants;
    let conference_record = params.conference_record;
    let conference_trim = params.conference_trim;
    let conference_status_callback = params.conference_status_callback;
    let conference_status_callback_method = params.conference_status_callback_method;
    let conference_status_callback_event = params.conference_status_callback_event;
    let recording_channels = params.recording_channels;
    let recording_status_callback = params.recording_status_callback;
    let recording_status_callback_method = params.recording_status_callback_method;
    let sip_auth_username = params.sip_auth_username;
    let sip_auth_password = params.sip_auth_password;
    let region = params.region;
    let conference_recording_status_callback = params.conference_recording_status_callback;
    let conference_recording_status_callback_method = params.conference_recording_status_callback_method;
    let recording_status_callback_event = params.recording_status_callback_event;
    let conference_recording_status_callback_event = params.conference_recording_status_callback_event;
    let coaching = params.coaching;
    let call_sid_to_coach = params.call_sid_to_coach;
    let jitter_buffer_size = params.jitter_buffer_size;
    let byoc = params.byoc;
    let caller_id = params.caller_id;
    let call_reason = params.call_reason;
    let recording_track = params.recording_track;
    let time_limit = params.time_limit;
    let machine_detection = params.machine_detection;
    let machine_detection_timeout = params.machine_detection_timeout;
    let machine_detection_speech_threshold = params.machine_detection_speech_threshold;
    let machine_detection_speech_end_threshold = params.machine_detection_speech_end_threshold;
    let machine_detection_silence_timeout = params.machine_detection_silence_timeout;
    let amd_status_callback = params.amd_status_callback;
    let amd_status_callback_method = params.amd_status_callback_method;
    let trim = params.trim;
    let call_token = params.call_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    local_var_form_params.insert("From", from.to_string());
    local_var_form_params.insert("To", to.to_string());
    if let Some(local_var_param_value) = status_callback {
        local_var_form_params.insert("StatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_method {
        local_var_form_params.insert("StatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = status_callback_event {
        local_var_form_params.insert("StatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = label {
        local_var_form_params.insert("Label", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = timeout {
        local_var_form_params.insert("Timeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = record {
        local_var_form_params.insert("Record", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = muted {
        local_var_form_params.insert("Muted", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = beep {
        local_var_form_params.insert("Beep", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = start_conference_on_enter {
        local_var_form_params.insert("StartConferenceOnEnter", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = end_conference_on_exit {
        local_var_form_params.insert("EndConferenceOnExit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = wait_url {
        local_var_form_params.insert("WaitUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = wait_method {
        local_var_form_params.insert("WaitMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = early_media {
        local_var_form_params.insert("EarlyMedia", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = max_participants {
        local_var_form_params.insert("MaxParticipants", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_record {
        local_var_form_params.insert("ConferenceRecord", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_trim {
        local_var_form_params.insert("ConferenceTrim", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_status_callback {
        local_var_form_params.insert("ConferenceStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_status_callback_method {
        local_var_form_params.insert("ConferenceStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_status_callback_event {
        local_var_form_params.insert("ConferenceStatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = recording_channels {
        local_var_form_params.insert("RecordingChannels", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback {
        local_var_form_params.insert("RecordingStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback_method {
        local_var_form_params.insert("RecordingStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sip_auth_username {
        local_var_form_params.insert("SipAuthUsername", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = sip_auth_password {
        local_var_form_params.insert("SipAuthPassword", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = region {
        local_var_form_params.insert("Region", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_recording_status_callback {
        local_var_form_params.insert("ConferenceRecordingStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = conference_recording_status_callback_method {
        local_var_form_params.insert("ConferenceRecordingStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_status_callback_event {
        local_var_form_params.insert("RecordingStatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = conference_recording_status_callback_event {
        local_var_form_params.insert("ConferenceRecordingStatusCallbackEvent", local_var_param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(local_var_param_value) = coaching {
        local_var_form_params.insert("Coaching", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_sid_to_coach {
        local_var_form_params.insert("CallSidToCoach", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = jitter_buffer_size {
        local_var_form_params.insert("JitterBufferSize", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = byoc {
        local_var_form_params.insert("Byoc", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = caller_id {
        local_var_form_params.insert("CallerId", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_reason {
        local_var_form_params.insert("CallReason", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = recording_track {
        local_var_form_params.insert("RecordingTrack", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = time_limit {
        local_var_form_params.insert("TimeLimit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = machine_detection {
        local_var_form_params.insert("MachineDetection", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = machine_detection_timeout {
        local_var_form_params.insert("MachineDetectionTimeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = machine_detection_speech_threshold {
        local_var_form_params.insert("MachineDetectionSpeechThreshold", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = machine_detection_speech_end_threshold {
        local_var_form_params.insert("MachineDetectionSpeechEndThreshold", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = machine_detection_silence_timeout {
        local_var_form_params.insert("MachineDetectionSilenceTimeout", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = amd_status_callback {
        local_var_form_params.insert("AmdStatusCallback", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = amd_status_callback_method {
        local_var_form_params.insert("AmdStatusCallbackMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = trim {
        local_var_form_params.insert("Trim", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_token {
        local_var_form_params.insert("CallToken", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Kick a participant from a given conference
pub async fn delete_participant(configuration: &configuration::Configuration, params: DeleteParticipantParams) -> Result<(), Error<DeleteParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let call_sid = params.call_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch an instance of a participant
pub async fn fetch_participant(configuration: &configuration::Configuration, params: FetchParticipantParams) -> Result<crate::models::ApiPeriodV2010PeriodAccountPeriodConferencePeriodParticipant, Error<FetchParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let call_sid = params.call_sid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<FetchParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve a list of participants belonging to the account used to make the request
pub async fn list_participant(configuration: &configuration::Configuration, params: ListParticipantParams) -> Result<crate::models::ListParticipantResponse, Error<ListParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let muted = params.muted;
    let hold = params.hold;
    let coaching = params.coaching;
    let page_size = params.page_size;
    let page = params.page;
    let page_token = params.page_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = muted {
        local_var_req_builder = local_var_req_builder.query(&[("Muted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = hold {
        local_var_req_builder = local_var_req_builder.query(&[("Hold", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = coaching {
        local_var_req_builder = local_var_req_builder.query(&[("Coaching", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("PageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("Page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder = local_var_req_builder.query(&[("PageToken", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the properties of the participant
pub async fn update_participant(configuration: &configuration::Configuration, params: UpdateParticipantParams) -> Result<crate::models::ApiPeriodV2010PeriodAccountPeriodConferencePeriodParticipant, Error<UpdateParticipantError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_sid = params.account_sid;
    let conference_sid = params.conference_sid;
    let call_sid = params.call_sid;
    let muted = params.muted;
    let hold = params.hold;
    let hold_url = params.hold_url;
    let hold_method = params.hold_method;
    let announce_url = params.announce_url;
    let announce_method = params.announce_method;
    let wait_url = params.wait_url;
    let wait_method = params.wait_method;
    let beep_on_exit = params.beep_on_exit;
    let end_conference_on_exit = params.end_conference_on_exit;
    let coaching = params.coaching;
    let call_sid_to_coach = params.call_sid_to_coach;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json", local_var_configuration.base_path, AccountSid=crate::apis::urlencode(account_sid), ConferenceSid=crate::apis::urlencode(conference_sid), CallSid=crate::apis::urlencode(call_sid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    let mut local_var_form_params = std::collections::HashMap::new();
    if let Some(local_var_param_value) = muted {
        local_var_form_params.insert("Muted", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = hold {
        local_var_form_params.insert("Hold", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = hold_url {
        local_var_form_params.insert("HoldUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = hold_method {
        local_var_form_params.insert("HoldMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = announce_url {
        local_var_form_params.insert("AnnounceUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = announce_method {
        local_var_form_params.insert("AnnounceMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = wait_url {
        local_var_form_params.insert("WaitUrl", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = wait_method {
        local_var_form_params.insert("WaitMethod", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = beep_on_exit {
        local_var_form_params.insert("BeepOnExit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = end_conference_on_exit {
        local_var_form_params.insert("EndConferenceOnExit", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = coaching {
        local_var_form_params.insert("Coaching", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = call_sid_to_coach {
        local_var_form_params.insert("CallSidToCoach", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.form(&local_var_form_params);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateParticipantError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

